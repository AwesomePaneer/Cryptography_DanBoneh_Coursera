from gmpy2 import mpz,isqrt,mul,powmod,digits
import gmpy2
import math
gmpy2.get_context().precision = 1000

def extended_gcd(a, b):
    """
    Compute the extended Euclidean algorithm and return the greatest common divisor
    as well as the coefficients x and y such that ax + by = gcd(a, b).
    """
    if b == 0:
        return a, 1, 0
    else:
        g, y, x = extended_gcd(b, a % b)
        return g, x, y - (a // b) * x

def hex_to_ascii_string(hex):
    return bytes.fromhex(hex).decode('ascii')

# challenge 1
print('Challenge 1')
N = mpz(179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581)
A = mpz(isqrt(N) + 1)
x = isqrt(A**2 - N)
p = A-x
q = A+x
print(p.__str__())

# challenge 2
print('\nChallenge 2')
N = mpz(648455842808071669662824265346772278726343720706976263060439070378797308618081116462714015276061417569195587321840254520655424906719892428844841839353281972988531310511738648965962582821502504990264452100885281673303711142296421027840289307657458645233683357077834689715838646088239640236866252211790085787877)
temp = isqrt(N)
for i in range(1,2**20+1):
    A = mpz(i+temp)
    x = isqrt(A**2 - N)
    p = mpz(A-x)
    q = mpz(A+x)
    N_test = mul(p,q)
    if N_test == N:
        print(p.__str__())
        break

# challenge 3
print('\nChallenge 3')
N = mpz(720062263747350425279564435525583738338084451473999841826653057981916355690188337790423408664187663938485175264994017897083524079135686877441155132015188279331812309091996246361896836573643119174094961348524639707885238799396839230364676670221627018353299443241192173812729276147530748597302192751375739387929)
A = mpz(isqrt(6*N)+1)-0.5   # since (3p+2q)/2 is not an integer, isqrt(6N)+1 gives (3p+2q+1)/2
x = gmpy2.sqrt(A**2 - 6*N)
p = (A-x)/3     # almost an integer (notice the .0000000). It would have been an integer had we had infinite precision (which is impossible)
q = (A+x)/2     # we still get the integer part though by observing the decimals manually or using ceil and floor functions
print(x)
print(p.__str__())      # printed with fractional part to observe what happened in this snippet of code
print(q.__str__())

print('\nChallenge 4')
cipher = mpz(22096451867410381776306561134883418017410069787892831071731839143676135600120538004282329650473509424343946219751512256465839967942889460764542040581564748988013734864120452325229320176487916666402997509188729971690526083222067771600019329260870009579993724077458967773697817571267229951148662959627934791540)
N = mpz(179769313486231590772930519078902473361797697894230657273430081157732675805505620686985379449212982959585501387537164015710139858647833778606925583497541085196591615128057575940752635007475935288710823649949940771895617054361149474865046711015101563940680527540071584560878577663743040086340742855278549092581)
p = mpz(13407807929942597099574024998205846127479365820592393377723561443721764030073662768891111614362326998675040546094339320838419523375986027530441562135724301)
q = mpz(13407807929942597099574024998205846127479365820592393377723561443721764030073778560980348930557750569660049234002192590823085163940025485114449475265364281)
e = mpz(65537)
phi_N = mul(p-1,q-1)
g, x, y = extended_gcd(e, phi_N)
d = x % phi_N
plaintext_decimal = powmod(cipher,d,N)
plaintext_hex = digits(plaintext_decimal,16)
plaintext_padding_removed = plaintext_hex.split('00')[1]
plaintext = hex_to_ascii_string(plaintext_padding_removed)
print(plaintext)